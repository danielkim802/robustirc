// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: snapshot.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Bool represents a boolean which can either be unset, true or
// false. This quirk is necessary because proto3 does not distinguish
// the default value (false) from a field not being set, which would
// not allow us to do upgrades from older versions of RobustIRC to
// newer versions of RobustIRC which introduce a new boolean field.
type Bool int32

const (
	Bool_UNSET Bool = 0
	Bool_TRUE  Bool = 1
	Bool_FALSE Bool = 2
)

var Bool_name = map[int32]string{
	0: "UNSET",
	1: "TRUE",
	2: "FALSE",
}

var Bool_value = map[string]int32{
	"UNSET": 0,
	"TRUE":  1,
	"FALSE": 2,
}

func (x Bool) String() string {
	return proto.EnumName(Bool_name, int32(x))
}

func (Bool) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{0}
}

// Timestamp serializes a Go time.Time value with correct IsZero()
// semantics. Merely serializing the UnixNano() value is not
// sufficient, see https://play.golang.org/p/n3ZWGwZCKR
type Timestamp struct {
	UnixNano             int64    `protobuf:"varint,1,opt,name=unix_nano,json=unixNano,proto3" json:"unix_nano,omitempty"`
	IsZero               bool     `protobuf:"varint,2,opt,name=is_zero,json=isZero,proto3" json:"is_zero,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{0}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetUnixNano() int64 {
	if m != nil {
		return m.UnixNano
	}
	return 0
}

func (m *Timestamp) GetIsZero() bool {
	if m != nil {
		return m.IsZero
	}
	return false
}

// Snapshot contains the entire state of an IRCServer object, so that
// a new IRCServer object can be created with exactly the same state.
type Snapshot struct {
	Sessions      []*Snapshot_Session          `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	Channels      []*Snapshot_Channel          `protobuf:"bytes,2,rep,name=channels,proto3" json:"channels,omitempty"`
	Svsholds      map[string]*Snapshot_SVSHold `protobuf:"bytes,3,rep,name=svsholds,proto3" json:"svsholds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LastProcessed *RobustId                    `protobuf:"bytes,4,opt,name=last_processed,json=lastProcessed,proto3" json:"last_processed,omitempty"`
	Config        *Snapshot_Config             `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`
	// last_included_index is the last ircstore message index which was
	// included when taking the snapshot. This is relevant to store this
	// snapshot in fsm.lastSnapshotState when restoring after ircstore
	// was deleted.
	LastIncludedIndex    uint64   `protobuf:"varint,6,opt,name=last_included_index,json=lastIncludedIndex,proto3" json:"last_included_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetSessions() []*Snapshot_Session {
	if m != nil {
		return m.Sessions
	}
	return nil
}

func (m *Snapshot) GetChannels() []*Snapshot_Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *Snapshot) GetSvsholds() map[string]*Snapshot_SVSHold {
	if m != nil {
		return m.Svsholds
	}
	return nil
}

func (m *Snapshot) GetLastProcessed() *RobustId {
	if m != nil {
		return m.LastProcessed
	}
	return nil
}

func (m *Snapshot) GetConfig() *Snapshot_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Snapshot) GetLastIncludedIndex() uint64 {
	if m != nil {
		return m.LastIncludedIndex
	}
	return 0
}

type Snapshot_IRCPrefix struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	User                 string   `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	Host                 string   `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot_IRCPrefix) Reset()         { *m = Snapshot_IRCPrefix{} }
func (m *Snapshot_IRCPrefix) String() string { return proto.CompactTextString(m) }
func (*Snapshot_IRCPrefix) ProtoMessage()    {}
func (*Snapshot_IRCPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 0}
}
func (m *Snapshot_IRCPrefix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_IRCPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_IRCPrefix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_IRCPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_IRCPrefix.Merge(m, src)
}
func (m *Snapshot_IRCPrefix) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_IRCPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_IRCPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_IRCPrefix proto.InternalMessageInfo

func (m *Snapshot_IRCPrefix) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Snapshot_IRCPrefix) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Snapshot_IRCPrefix) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type Snapshot_Session struct {
	Id                   *RobustId           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Auth                 string              `protobuf:"bytes,2,opt,name=auth,proto3" json:"auth,omitempty"`
	Nick                 string              `protobuf:"bytes,3,opt,name=nick,proto3" json:"nick,omitempty"`
	Username             string              `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Realname             string              `protobuf:"bytes,5,opt,name=realname,proto3" json:"realname,omitempty"`
	Channels             []string            `protobuf:"bytes,6,rep,name=channels,proto3" json:"channels,omitempty"`
	LastActivity         *Timestamp          `protobuf:"bytes,7,opt,name=last_activity,json=lastActivity,proto3" json:"last_activity,omitempty"`
	Operator             bool                `protobuf:"varint,8,opt,name=operator,proto3" json:"operator,omitempty"`
	AwayMsg              string              `protobuf:"bytes,9,opt,name=away_msg,json=awayMsg,proto3" json:"away_msg,omitempty"`
	Created              int64               `protobuf:"varint,22,opt,name=created,proto3" json:"created,omitempty"`
	ThrottlingExponent   int64               `protobuf:"varint,10,opt,name=throttling_exponent,json=throttlingExponent,proto3" json:"throttling_exponent,omitempty"`
	InvitedTo            []string            `protobuf:"bytes,11,rep,name=invited_to,json=invitedTo,proto3" json:"invited_to,omitempty"`
	Modes                []string            `protobuf:"bytes,12,rep,name=modes,proto3" json:"modes,omitempty"`
	Svid                 string              `protobuf:"bytes,13,opt,name=svid,proto3" json:"svid,omitempty"`
	Pass                 string              `protobuf:"bytes,14,opt,name=pass,proto3" json:"pass,omitempty"`
	Server               bool                `protobuf:"varint,15,opt,name=server,proto3" json:"server,omitempty"`
	LastClientMessageId  uint64              `protobuf:"varint,17,opt,name=last_client_message_id,json=lastClientMessageId,proto3" json:"last_client_message_id,omitempty"`
	IrcPrefix            *Snapshot_IRCPrefix `protobuf:"bytes,18,opt,name=irc_prefix,json=ircPrefix,proto3" json:"irc_prefix,omitempty"`
	LastNonPing          *Timestamp          `protobuf:"bytes,19,opt,name=last_non_ping,json=lastNonPing,proto3" json:"last_non_ping,omitempty"`
	LastSolvedCaptcha    *Timestamp          `protobuf:"bytes,20,opt,name=last_solved_captcha,json=lastSolvedCaptcha,proto3" json:"last_solved_captcha,omitempty"`
	LoggedIn             Bool                `protobuf:"varint,21,opt,name=logged_in,json=loggedIn,proto3,enum=proto.Bool" json:"logged_in,omitempty"`
	RemoteAddr           string              `protobuf:"bytes,23,opt,name=remote_addr,json=remoteAddr,proto3" json:"remote_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Snapshot_Session) Reset()         { *m = Snapshot_Session{} }
func (m *Snapshot_Session) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Session) ProtoMessage()    {}
func (*Snapshot_Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 1}
}
func (m *Snapshot_Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Session.Merge(m, src)
}
func (m *Snapshot_Session) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Session proto.InternalMessageInfo

func (m *Snapshot_Session) GetId() *RobustId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Snapshot_Session) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

func (m *Snapshot_Session) GetNick() string {
	if m != nil {
		return m.Nick
	}
	return ""
}

func (m *Snapshot_Session) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Snapshot_Session) GetRealname() string {
	if m != nil {
		return m.Realname
	}
	return ""
}

func (m *Snapshot_Session) GetChannels() []string {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *Snapshot_Session) GetLastActivity() *Timestamp {
	if m != nil {
		return m.LastActivity
	}
	return nil
}

func (m *Snapshot_Session) GetOperator() bool {
	if m != nil {
		return m.Operator
	}
	return false
}

func (m *Snapshot_Session) GetAwayMsg() string {
	if m != nil {
		return m.AwayMsg
	}
	return ""
}

func (m *Snapshot_Session) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Snapshot_Session) GetThrottlingExponent() int64 {
	if m != nil {
		return m.ThrottlingExponent
	}
	return 0
}

func (m *Snapshot_Session) GetInvitedTo() []string {
	if m != nil {
		return m.InvitedTo
	}
	return nil
}

func (m *Snapshot_Session) GetModes() []string {
	if m != nil {
		return m.Modes
	}
	return nil
}

func (m *Snapshot_Session) GetSvid() string {
	if m != nil {
		return m.Svid
	}
	return ""
}

func (m *Snapshot_Session) GetPass() string {
	if m != nil {
		return m.Pass
	}
	return ""
}

func (m *Snapshot_Session) GetServer() bool {
	if m != nil {
		return m.Server
	}
	return false
}

func (m *Snapshot_Session) GetLastClientMessageId() uint64 {
	if m != nil {
		return m.LastClientMessageId
	}
	return 0
}

func (m *Snapshot_Session) GetIrcPrefix() *Snapshot_IRCPrefix {
	if m != nil {
		return m.IrcPrefix
	}
	return nil
}

func (m *Snapshot_Session) GetLastNonPing() *Timestamp {
	if m != nil {
		return m.LastNonPing
	}
	return nil
}

func (m *Snapshot_Session) GetLastSolvedCaptcha() *Timestamp {
	if m != nil {
		return m.LastSolvedCaptcha
	}
	return nil
}

func (m *Snapshot_Session) GetLoggedIn() Bool {
	if m != nil {
		return m.LoggedIn
	}
	return Bool_UNSET
}

func (m *Snapshot_Session) GetRemoteAddr() string {
	if m != nil {
		return m.RemoteAddr
	}
	return ""
}

type Snapshot_Channel struct {
	Name                 string                             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TopicNick            string                             `protobuf:"bytes,2,opt,name=topic_nick,json=topicNick,proto3" json:"topic_nick,omitempty"`
	TopicTime            *Timestamp                         `protobuf:"bytes,3,opt,name=topic_time,json=topicTime,proto3" json:"topic_time,omitempty"`
	Topic                string                             `protobuf:"bytes,4,opt,name=topic,proto3" json:"topic,omitempty"`
	Nicks                map[string]*Snapshot_Channel_Modes `protobuf:"bytes,5,rep,name=nicks,proto3" json:"nicks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Modes                []string                           `protobuf:"bytes,6,rep,name=modes,proto3" json:"modes,omitempty"`
	Bans                 []*Snapshot_Channel_BanPattern     `protobuf:"bytes,7,rep,name=bans,proto3" json:"bans,omitempty"`
	Key                  string                             `protobuf:"bytes,8,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *Snapshot_Channel) Reset()         { *m = Snapshot_Channel{} }
func (m *Snapshot_Channel) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Channel) ProtoMessage()    {}
func (*Snapshot_Channel) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 2}
}
func (m *Snapshot_Channel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Channel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Channel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Channel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Channel.Merge(m, src)
}
func (m *Snapshot_Channel) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Channel) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Channel.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Channel proto.InternalMessageInfo

func (m *Snapshot_Channel) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Snapshot_Channel) GetTopicNick() string {
	if m != nil {
		return m.TopicNick
	}
	return ""
}

func (m *Snapshot_Channel) GetTopicTime() *Timestamp {
	if m != nil {
		return m.TopicTime
	}
	return nil
}

func (m *Snapshot_Channel) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Snapshot_Channel) GetNicks() map[string]*Snapshot_Channel_Modes {
	if m != nil {
		return m.Nicks
	}
	return nil
}

func (m *Snapshot_Channel) GetModes() []string {
	if m != nil {
		return m.Modes
	}
	return nil
}

func (m *Snapshot_Channel) GetBans() []*Snapshot_Channel_BanPattern {
	if m != nil {
		return m.Bans
	}
	return nil
}

func (m *Snapshot_Channel) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// Modes is a workaround because proto3 does not support
// map<string, repeated string>.
type Snapshot_Channel_Modes struct {
	Mode                 []string `protobuf:"bytes,1,rep,name=mode,proto3" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot_Channel_Modes) Reset()         { *m = Snapshot_Channel_Modes{} }
func (m *Snapshot_Channel_Modes) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Channel_Modes) ProtoMessage()    {}
func (*Snapshot_Channel_Modes) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 2, 0}
}
func (m *Snapshot_Channel_Modes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Channel_Modes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Channel_Modes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Channel_Modes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Channel_Modes.Merge(m, src)
}
func (m *Snapshot_Channel_Modes) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Channel_Modes) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Channel_Modes.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Channel_Modes proto.InternalMessageInfo

func (m *Snapshot_Channel_Modes) GetMode() []string {
	if m != nil {
		return m.Mode
	}
	return nil
}

type Snapshot_Channel_BanPattern struct {
	Pattern              string   `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	Regexp               string   `protobuf:"bytes,2,opt,name=regexp,proto3" json:"regexp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot_Channel_BanPattern) Reset()         { *m = Snapshot_Channel_BanPattern{} }
func (m *Snapshot_Channel_BanPattern) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Channel_BanPattern) ProtoMessage()    {}
func (*Snapshot_Channel_BanPattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 2, 2}
}
func (m *Snapshot_Channel_BanPattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Channel_BanPattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Channel_BanPattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Channel_BanPattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Channel_BanPattern.Merge(m, src)
}
func (m *Snapshot_Channel_BanPattern) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Channel_BanPattern) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Channel_BanPattern.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Channel_BanPattern proto.InternalMessageInfo

func (m *Snapshot_Channel_BanPattern) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *Snapshot_Channel_BanPattern) GetRegexp() string {
	if m != nil {
		return m.Regexp
	}
	return ""
}

type Snapshot_SVSHold struct {
	Added                *Timestamp `protobuf:"bytes,1,opt,name=added,proto3" json:"added,omitempty"`
	Duration             string     `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty"`
	Reason               string     `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Snapshot_SVSHold) Reset()         { *m = Snapshot_SVSHold{} }
func (m *Snapshot_SVSHold) String() string { return proto.CompactTextString(m) }
func (*Snapshot_SVSHold) ProtoMessage()    {}
func (*Snapshot_SVSHold) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 3}
}
func (m *Snapshot_SVSHold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_SVSHold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_SVSHold.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_SVSHold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_SVSHold.Merge(m, src)
}
func (m *Snapshot_SVSHold) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_SVSHold) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_SVSHold.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_SVSHold proto.InternalMessageInfo

func (m *Snapshot_SVSHold) GetAdded() *Timestamp {
	if m != nil {
		return m.Added
	}
	return nil
}

func (m *Snapshot_SVSHold) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *Snapshot_SVSHold) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type Snapshot_Config struct {
	Revision                uint64               `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	Irc                     *Snapshot_Config_IRC `protobuf:"bytes,2,opt,name=irc,proto3" json:"irc,omitempty"`
	SessionExpiration       string               `protobuf:"bytes,3,opt,name=session_expiration,json=sessionExpiration,proto3" json:"session_expiration,omitempty"`
	PostMessageCooloff      string               `protobuf:"bytes,4,opt,name=post_message_cooloff,json=postMessageCooloff,proto3" json:"post_message_cooloff,omitempty"`
	TrustedBridges          map[string]string    `protobuf:"bytes,5,rep,name=trusted_bridges,json=trustedBridges,proto3" json:"trusted_bridges,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CaptchaUrl              string               `protobuf:"bytes,6,opt,name=captcha_url,json=captchaUrl,proto3" json:"captcha_url,omitempty"`
	CaptchaHmacSecret       string               `protobuf:"bytes,7,opt,name=captcha_hmac_secret,json=captchaHmacSecret,proto3" json:"captcha_hmac_secret,omitempty"`
	CaptchaRequiredForLogin bool                 `protobuf:"varint,8,opt,name=captcha_required_for_login,json=captchaRequiredForLogin,proto3" json:"captcha_required_for_login,omitempty"`
	MaxSessions             uint64               `protobuf:"varint,9,opt,name=max_sessions,json=maxSessions,proto3" json:"max_sessions,omitempty"`
	MaxChannels             uint64               `protobuf:"varint,10,opt,name=max_channels,json=maxChannels,proto3" json:"max_channels,omitempty"`
	Banned                  map[string]string    `protobuf:"bytes,11,rep,name=banned,proto3" json:"banned,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral    struct{}             `json:"-"`
	XXX_unrecognized        []byte               `json:"-"`
	XXX_sizecache           int32                `json:"-"`
}

func (m *Snapshot_Config) Reset()         { *m = Snapshot_Config{} }
func (m *Snapshot_Config) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Config) ProtoMessage()    {}
func (*Snapshot_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 5}
}
func (m *Snapshot_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Config.Merge(m, src)
}
func (m *Snapshot_Config) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Config proto.InternalMessageInfo

func (m *Snapshot_Config) GetRevision() uint64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *Snapshot_Config) GetIrc() *Snapshot_Config_IRC {
	if m != nil {
		return m.Irc
	}
	return nil
}

func (m *Snapshot_Config) GetSessionExpiration() string {
	if m != nil {
		return m.SessionExpiration
	}
	return ""
}

func (m *Snapshot_Config) GetPostMessageCooloff() string {
	if m != nil {
		return m.PostMessageCooloff
	}
	return ""
}

func (m *Snapshot_Config) GetTrustedBridges() map[string]string {
	if m != nil {
		return m.TrustedBridges
	}
	return nil
}

func (m *Snapshot_Config) GetCaptchaUrl() string {
	if m != nil {
		return m.CaptchaUrl
	}
	return ""
}

func (m *Snapshot_Config) GetCaptchaHmacSecret() string {
	if m != nil {
		return m.CaptchaHmacSecret
	}
	return ""
}

func (m *Snapshot_Config) GetCaptchaRequiredForLogin() bool {
	if m != nil {
		return m.CaptchaRequiredForLogin
	}
	return false
}

func (m *Snapshot_Config) GetMaxSessions() uint64 {
	if m != nil {
		return m.MaxSessions
	}
	return 0
}

func (m *Snapshot_Config) GetMaxChannels() uint64 {
	if m != nil {
		return m.MaxChannels
	}
	return 0
}

func (m *Snapshot_Config) GetBanned() map[string]string {
	if m != nil {
		return m.Banned
	}
	return nil
}

type Snapshot_Config_IRC struct {
	Operators            []*Snapshot_Config_IRC_Operator `protobuf:"bytes,1,rep,name=operators,proto3" json:"operators,omitempty"`
	Services             []*Snapshot_Config_IRC_Service  `protobuf:"bytes,2,rep,name=services,proto3" json:"services,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *Snapshot_Config_IRC) Reset()         { *m = Snapshot_Config_IRC{} }
func (m *Snapshot_Config_IRC) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Config_IRC) ProtoMessage()    {}
func (*Snapshot_Config_IRC) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 5, 0}
}
func (m *Snapshot_Config_IRC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Config_IRC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Config_IRC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Config_IRC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Config_IRC.Merge(m, src)
}
func (m *Snapshot_Config_IRC) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Config_IRC) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Config_IRC.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Config_IRC proto.InternalMessageInfo

func (m *Snapshot_Config_IRC) GetOperators() []*Snapshot_Config_IRC_Operator {
	if m != nil {
		return m.Operators
	}
	return nil
}

func (m *Snapshot_Config_IRC) GetServices() []*Snapshot_Config_IRC_Service {
	if m != nil {
		return m.Services
	}
	return nil
}

type Snapshot_Config_IRC_Operator struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot_Config_IRC_Operator) Reset()         { *m = Snapshot_Config_IRC_Operator{} }
func (m *Snapshot_Config_IRC_Operator) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Config_IRC_Operator) ProtoMessage()    {}
func (*Snapshot_Config_IRC_Operator) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 5, 0, 0}
}
func (m *Snapshot_Config_IRC_Operator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Config_IRC_Operator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Config_IRC_Operator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Config_IRC_Operator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Config_IRC_Operator.Merge(m, src)
}
func (m *Snapshot_Config_IRC_Operator) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Config_IRC_Operator) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Config_IRC_Operator.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Config_IRC_Operator proto.InternalMessageInfo

func (m *Snapshot_Config_IRC_Operator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Snapshot_Config_IRC_Operator) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type Snapshot_Config_IRC_Service struct {
	Password             string   `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot_Config_IRC_Service) Reset()         { *m = Snapshot_Config_IRC_Service{} }
func (m *Snapshot_Config_IRC_Service) String() string { return proto.CompactTextString(m) }
func (*Snapshot_Config_IRC_Service) ProtoMessage()    {}
func (*Snapshot_Config_IRC_Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c8aab8e59648e0b, []int{1, 5, 0, 1}
}
func (m *Snapshot_Config_IRC_Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot_Config_IRC_Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot_Config_IRC_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot_Config_IRC_Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot_Config_IRC_Service.Merge(m, src)
}
func (m *Snapshot_Config_IRC_Service) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot_Config_IRC_Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot_Config_IRC_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot_Config_IRC_Service proto.InternalMessageInfo

func (m *Snapshot_Config_IRC_Service) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func init() {
	proto.RegisterEnum("proto.Bool", Bool_name, Bool_value)
	proto.RegisterType((*Timestamp)(nil), "proto.Timestamp")
	proto.RegisterType((*Snapshot)(nil), "proto.Snapshot")
	proto.RegisterMapType((map[string]*Snapshot_SVSHold)(nil), "proto.Snapshot.SvsholdsEntry")
	proto.RegisterType((*Snapshot_IRCPrefix)(nil), "proto.Snapshot.IRCPrefix")
	proto.RegisterType((*Snapshot_Session)(nil), "proto.Snapshot.Session")
	proto.RegisterType((*Snapshot_Channel)(nil), "proto.Snapshot.Channel")
	proto.RegisterMapType((map[string]*Snapshot_Channel_Modes)(nil), "proto.Snapshot.Channel.NicksEntry")
	proto.RegisterType((*Snapshot_Channel_Modes)(nil), "proto.Snapshot.Channel.Modes")
	proto.RegisterType((*Snapshot_Channel_BanPattern)(nil), "proto.Snapshot.Channel.BanPattern")
	proto.RegisterType((*Snapshot_SVSHold)(nil), "proto.Snapshot.SVSHold")
	proto.RegisterType((*Snapshot_Config)(nil), "proto.Snapshot.Config")
	proto.RegisterMapType((map[string]string)(nil), "proto.Snapshot.Config.BannedEntry")
	proto.RegisterMapType((map[string]string)(nil), "proto.Snapshot.Config.TrustedBridgesEntry")
	proto.RegisterType((*Snapshot_Config_IRC)(nil), "proto.Snapshot.Config.IRC")
	proto.RegisterType((*Snapshot_Config_IRC_Operator)(nil), "proto.Snapshot.Config.IRC.Operator")
	proto.RegisterType((*Snapshot_Config_IRC_Service)(nil), "proto.Snapshot.Config.IRC.Service")
}

func init() { proto.RegisterFile("snapshot.proto", fileDescriptor_0c8aab8e59648e0b) }

var fileDescriptor_0c8aab8e59648e0b = []byte{
	// 1329 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdd, 0x6e, 0x1b, 0xb7,
	0x12, 0xce, 0x5a, 0xbf, 0x3b, 0x4a, 0x1c, 0x99, 0x76, 0xec, 0xcd, 0x06, 0xf1, 0xf1, 0xf1, 0xc1,
	0x09, 0x8c, 0xa0, 0x71, 0x8a, 0xb8, 0x0d, 0x92, 0x14, 0x08, 0x6a, 0x0b, 0x4e, 0xa3, 0x22, 0x71,
	0x0d, 0xca, 0x69, 0x81, 0xde, 0x2c, 0xe8, 0x5d, 0x5a, 0x22, 0xb2, 0x22, 0xb7, 0x24, 0xa5, 0xc8,
	0xbd, 0xee, 0x65, 0x1f, 0xa0, 0xaf, 0xd2, 0x37, 0xe8, 0x65, 0x81, 0xbe, 0x40, 0x91, 0x5e, 0xf6,
	0x25, 0x0a, 0xfe, 0xec, 0xda, 0x8e, 0xe5, 0x00, 0xbd, 0x5a, 0xce, 0x7c, 0xdf, 0x0c, 0xb9, 0xc3,
	0xf9, 0x21, 0x2c, 0x2a, 0x4e, 0x0a, 0x35, 0x12, 0x7a, 0xbb, 0x90, 0x42, 0x0b, 0xd4, 0xb0, 0x9f,
	0xb8, 0xa3, 0x4f, 0x0b, 0xaa, 0x9c, 0x6e, 0x73, 0x17, 0xc2, 0x23, 0x36, 0xa6, 0x4a, 0x93, 0x71,
	0x81, 0xee, 0x40, 0x38, 0xe1, 0x6c, 0x96, 0x70, 0xc2, 0x45, 0x14, 0x6c, 0x04, 0x5b, 0x35, 0xdc,
	0x36, 0x8a, 0x03, 0xc2, 0x05, 0x5a, 0x83, 0x16, 0x53, 0xc9, 0x8f, 0x54, 0x8a, 0x68, 0x61, 0x23,
	0xd8, 0x6a, 0xe3, 0x26, 0x53, 0xdf, 0x53, 0x29, 0x36, 0x7f, 0xbd, 0x05, 0xed, 0x81, 0xdf, 0x09,
	0xed, 0x40, 0x5b, 0x51, 0xa5, 0x98, 0xe0, 0x2a, 0x0a, 0x36, 0x6a, 0x5b, 0x9d, 0x47, 0x6b, 0x6e,
	0xa7, 0xed, 0x92, 0xb2, 0x3d, 0x70, 0x38, 0xae, 0x88, 0xc6, 0x28, 0x1d, 0x11, 0xce, 0x69, 0xae,
	0xa2, 0x85, 0xf9, 0x46, 0x3d, 0x87, 0xe3, 0x8a, 0x88, 0x9e, 0x42, 0x5b, 0x4d, 0xd5, 0x48, 0xe4,
	0x99, 0x8a, 0x6a, 0xd6, 0xe8, 0xee, 0xa5, 0x9d, 0x3c, 0xbe, 0xcf, 0xb5, 0x3c, 0xc5, 0x15, 0x1d,
	0x3d, 0x86, 0xc5, 0x9c, 0x28, 0x9d, 0x14, 0x52, 0xa4, 0x54, 0x29, 0x9a, 0x45, 0xf5, 0x8d, 0x60,
	0xab, 0xf3, 0xe8, 0xa6, 0x77, 0x80, 0xc5, 0xf1, 0x44, 0xe9, 0x7e, 0x86, 0x6f, 0x18, 0xda, 0x61,
	0xc9, 0x42, 0xdb, 0xd0, 0x4c, 0x05, 0x3f, 0x61, 0xc3, 0xa8, 0x61, 0xf9, 0xab, 0x97, 0x4e, 0x69,
	0x51, 0xec, 0x59, 0x68, 0x1b, 0x96, 0xed, 0x3e, 0x8c, 0xa7, 0xf9, 0x24, 0xa3, 0x59, 0xc2, 0x78,
	0x46, 0x67, 0x51, 0x73, 0x23, 0xd8, 0xaa, 0xe3, 0x25, 0x03, 0xf5, 0x3d, 0xd2, 0x37, 0x40, 0xfc,
	0x15, 0x84, 0x7d, 0xdc, 0x3b, 0x94, 0xf4, 0x84, 0xcd, 0x10, 0x82, 0x3a, 0x27, 0x63, 0x6a, 0xef,
	0x21, 0xc4, 0x76, 0x6d, 0x74, 0x13, 0x45, 0xa5, 0xbd, 0x80, 0x10, 0xdb, 0xb5, 0xd1, 0x8d, 0x84,
	0xd2, 0x51, 0xcd, 0xe9, 0xcc, 0x3a, 0xfe, 0xb9, 0x09, 0x2d, 0x1f, 0x66, 0xf4, 0x1f, 0x58, 0x60,
	0x99, 0xf5, 0x32, 0xe7, 0x07, 0x17, 0x58, 0x66, 0x1c, 0x90, 0x89, 0x1e, 0x95, 0x4e, 0xcd, 0xda,
	0x6e, 0xce, 0xd2, 0xb7, 0xa5, 0x53, 0xb3, 0x46, 0x31, 0xb4, 0xcd, 0x86, 0xf6, 0x50, 0x75, 0xab,
	0xaf, 0x64, 0x83, 0x49, 0x4a, 0x72, 0x8b, 0x35, 0x1c, 0x56, 0xca, 0x06, 0xab, 0x6e, 0xb7, 0xb9,
	0x51, 0x33, 0x58, 0x75, 0x89, 0x9f, 0x83, 0x0d, 0x71, 0x42, 0x52, 0xcd, 0xa6, 0x4c, 0x9f, 0x46,
	0x2d, 0x7b, 0xce, 0xae, 0x3f, 0x67, 0x95, 0x9a, 0xf8, 0xba, 0xa1, 0xed, 0x7a, 0x96, 0x71, 0x29,
	0x0a, 0x2a, 0x89, 0x16, 0x32, 0x6a, 0xdb, 0x64, 0xac, 0x64, 0x74, 0x1b, 0xda, 0xe4, 0x1d, 0x39,
	0x4d, 0xc6, 0x6a, 0x18, 0x85, 0xf6, 0x28, 0x2d, 0x23, 0xbf, 0x56, 0x43, 0x14, 0x41, 0x2b, 0x95,
	0x94, 0x68, 0x9a, 0x45, 0xab, 0x36, 0xbb, 0x4b, 0x11, 0x3d, 0x84, 0x65, 0x3d, 0x92, 0x42, 0xeb,
	0x9c, 0xf1, 0x61, 0x42, 0x67, 0x85, 0xe0, 0x94, 0xeb, 0x08, 0x2c, 0x0b, 0x9d, 0x41, 0xfb, 0x1e,
	0x41, 0x77, 0x01, 0x18, 0x9f, 0x32, 0x4d, 0xb3, 0x44, 0x8b, 0xa8, 0x63, 0x7f, 0x2b, 0xf4, 0x9a,
	0x23, 0x81, 0x56, 0xa0, 0x31, 0x16, 0x19, 0x55, 0xd1, 0x75, 0x8b, 0x38, 0xc1, 0x44, 0x55, 0x4d,
	0x59, 0x16, 0xdd, 0x70, 0x51, 0x35, 0x6b, 0xa3, 0x2b, 0x88, 0x52, 0xd1, 0xa2, 0xd3, 0x99, 0x35,
	0x5a, 0x85, 0xa6, 0xa2, 0x72, 0x4a, 0x65, 0x74, 0xd3, 0x55, 0x9a, 0x93, 0xd0, 0x0e, 0xac, 0xda,
	0x68, 0xa5, 0x39, 0xa3, 0x5c, 0x27, 0x63, 0xaa, 0x14, 0x19, 0xd2, 0x84, 0x65, 0xd1, 0x92, 0x4d,
	0x29, 0x9b, 0x6d, 0x3d, 0x0b, 0xbe, 0x76, 0x58, 0x3f, 0x43, 0x4f, 0x00, 0x98, 0x4c, 0x93, 0xc2,
	0x66, 0x55, 0x84, 0x6c, 0x7c, 0x6f, 0x7f, 0x98, 0xb8, 0x55, 0xda, 0xe1, 0x90, 0xc9, 0xd4, 0x67,
	0xe0, 0x67, 0xfe, 0x72, 0xb8, 0xe0, 0x49, 0xc1, 0xf8, 0x30, 0x5a, 0xbe, 0xe2, 0x72, 0x3a, 0x86,
	0x76, 0x20, 0xf8, 0x21, 0xe3, 0x43, 0xf4, 0xa5, 0x4f, 0x7a, 0x25, 0xf2, 0x29, 0xcd, 0x92, 0x94,
	0x14, 0x3a, 0x1d, 0x91, 0x68, 0xe5, 0x0a, 0x5b, 0x5b, 0x06, 0x03, 0xcb, 0xed, 0x39, 0x2a, 0xda,
	0x82, 0x30, 0x17, 0xc3, 0xa1, 0xad, 0x97, 0xe8, 0xd6, 0x46, 0xb0, 0xb5, 0xf8, 0xa8, 0xe3, 0xed,
	0xf6, 0x84, 0xc8, 0x71, 0xdb, 0xa1, 0x7d, 0x93, 0xdb, 0x1d, 0x49, 0xc7, 0x42, 0xd3, 0x84, 0x64,
	0x99, 0x8c, 0xd6, 0x6c, 0x0c, 0xc1, 0xa9, 0x76, 0xb3, 0x4c, 0x7e, 0x5d, 0x6f, 0x77, 0xbb, 0x4b,
	0xf1, 0x1f, 0x35, 0x68, 0xf9, 0x06, 0x32, 0xb7, 0xac, 0xee, 0x02, 0x68, 0x51, 0xb0, 0x34, 0xb1,
	0x39, 0xef, 0xea, 0x20, 0xb4, 0x9a, 0x03, 0x93, 0xf8, 0x0f, 0x4b, 0x58, 0xb3, 0x31, 0xb5, 0x25,
	0x31, 0xef, 0x47, 0x9c, 0x81, 0x91, 0xcd, 0xed, 0x5b, 0xc1, 0x97, 0x89, 0x13, 0xd0, 0x13, 0x68,
	0x18, 0xff, 0x2a, 0x6a, 0xd8, 0x6e, 0xb5, 0x79, 0x45, 0x8b, 0xdb, 0x36, 0x7b, 0xfa, 0x96, 0xe5,
	0x0c, 0xce, 0xb2, 0xa9, 0x79, 0x3e, 0x9b, 0x1e, 0x43, 0xfd, 0x98, 0x70, 0x15, 0xb5, 0x3e, 0xee,
	0x6e, 0x8f, 0xf0, 0x43, 0xa2, 0x35, 0x95, 0x1c, 0x5b, 0x3e, 0xea, 0x42, 0xed, 0x2d, 0x3d, 0xb5,
	0x75, 0x13, 0x62, 0xb3, 0x8c, 0xef, 0x40, 0xe3, 0x75, 0x99, 0xa0, 0xc6, 0xb7, 0xed, 0xdc, 0x21,
	0xb6, 0xeb, 0xf8, 0x3b, 0x80, 0xb3, 0x13, 0x95, 0xc6, 0x41, 0x65, 0x8c, 0x76, 0xa0, 0x31, 0x25,
	0xf9, 0x84, 0xda, 0xb8, 0xcd, 0x69, 0xc2, 0xe5, 0x39, 0xec, 0x0e, 0xd8, 0x71, 0x9f, 0x2d, 0x3c,
	0x09, 0xe2, 0xe7, 0x00, 0x67, 0x67, 0x33, 0xb5, 0x59, 0xb8, 0xa5, 0x77, 0x5e, 0x8a, 0xa6, 0x1a,
	0x24, 0x1d, 0xd2, 0x59, 0xe1, 0x6f, 0xc6, 0x4b, 0x31, 0x85, 0xd6, 0xe0, 0xdb, 0xc1, 0x4b, 0x91,
	0x67, 0xe8, 0x1e, 0x34, 0x48, 0x96, 0xd1, 0xb2, 0xcd, 0x5d, 0xbe, 0x1c, 0x07, 0x9b, 0xbe, 0x91,
	0x4d, 0x24, 0xd1, 0x4c, 0x70, 0xef, 0xac, 0x92, 0xdd, 0x36, 0x44, 0x09, 0xee, 0x9b, 0x9e, 0x97,
	0xe2, 0x23, 0xb8, 0x71, 0x61, 0x8e, 0xcc, 0x09, 0xc1, 0x83, 0x8b, 0x21, 0xb8, 0x3c, 0xf1, 0xdc,
	0x31, 0xcf, 0xff, 0xfc, 0x4f, 0x2d, 0x68, 0xba, 0x69, 0xe1, 0x7a, 0xe7, 0x94, 0x99, 0x66, 0x6d,
	0x9d, 0xd6, 0x71, 0x25, 0xa3, 0x4f, 0xa0, 0xc6, 0x64, 0xea, 0xfd, 0xc6, 0xf3, 0xc7, 0x8d, 0x29,
	0x5e, 0x6c, 0x68, 0xe8, 0x01, 0x20, 0x3f, 0x53, 0x4d, 0x0b, 0x63, 0xfe, 0x47, 0xdd, 0xef, 0x2c,
	0x79, 0x64, 0xbf, 0x02, 0xd0, 0xa7, 0xb0, 0x52, 0x08, 0x75, 0xd6, 0x47, 0x52, 0x21, 0x72, 0x71,
	0x72, 0xe2, 0xb3, 0x16, 0x19, 0xcc, 0xb7, 0x91, 0x9e, 0x43, 0xd0, 0x00, 0x6e, 0x6a, 0x39, 0x51,
	0xa6, 0xeb, 0x1d, 0x4b, 0x96, 0x0d, 0x69, 0x99, 0xcc, 0xf7, 0xaf, 0x38, 0xda, 0x91, 0x63, 0xef,
	0x39, 0xb2, 0x4b, 0xea, 0x45, 0x7d, 0x41, 0x69, 0x8a, 0xd8, 0x37, 0x89, 0x64, 0x22, 0x73, 0x3b,
	0x1d, 0x43, 0x0c, 0x5e, 0xf5, 0x46, 0xe6, 0x66, 0x8c, 0x96, 0x84, 0xd1, 0x98, 0xa4, 0x89, 0xa2,
	0xa9, 0xa4, 0xda, 0x8e, 0x8a, 0x10, 0x2f, 0x79, 0xe8, 0xe5, 0x98, 0xa4, 0x03, 0x0b, 0xa0, 0x2f,
	0x20, 0x2e, 0xf9, 0x92, 0xfe, 0x30, 0x61, 0x92, 0x66, 0xc9, 0x89, 0x90, 0x49, 0x2e, 0x86, 0x8c,
	0xfb, 0x79, 0xb1, 0xe6, 0x19, 0xd8, 0x13, 0x5e, 0x08, 0xf9, 0xca, 0xc0, 0xe8, 0xbf, 0x70, 0x7d,
	0x4c, 0x66, 0x49, 0xf5, 0x88, 0x09, 0xed, 0x8d, 0x74, 0xc6, 0x64, 0x36, 0x28, 0x9f, 0x2b, 0x9e,
	0x52, 0x0d, 0x35, 0xa8, 0x28, 0xbd, 0x72, 0xae, 0x3d, 0x83, 0xe6, 0xb1, 0x59, 0x66, 0x76, 0x34,
	0xcc, 0xab, 0x4e, 0x17, 0x9f, 0x3d, 0x4b, 0x72, 0x71, 0xf1, 0x16, 0xf1, 0xdf, 0x01, 0xd4, 0xfa,
	0xb8, 0x87, 0x76, 0x21, 0x2c, 0x87, 0x5a, 0xf9, 0x96, 0xfa, 0xdf, 0xd5, 0x19, 0xb0, 0xfd, 0x8d,
	0xe7, 0xe2, 0x33, 0x2b, 0xf4, 0xdc, 0xbc, 0xc6, 0xe4, 0x94, 0xa5, 0xb4, 0x7c, 0x58, 0x6d, 0x7e,
	0xc4, 0xc3, 0xc0, 0x51, 0x71, 0x65, 0x13, 0x3f, 0x83, 0x76, 0xe9, 0x76, 0x6e, 0xe3, 0x8c, 0xa1,
	0x6d, 0x06, 0xd6, 0x3b, 0x21, 0xb3, 0xb2, 0x9e, 0x4a, 0x39, 0xfe, 0xbf, 0x79, 0x82, 0x58, 0x3f,
	0x17, 0x68, 0xc1, 0x07, 0xb4, 0x5d, 0x58, 0x9e, 0x93, 0x24, 0x73, 0x8a, 0x6c, 0xe5, 0x7c, 0x91,
	0x85, 0xe7, 0x6b, 0xe9, 0x29, 0x74, 0xce, 0xc5, 0xf1, 0xdf, 0x98, 0xde, 0xbf, 0x07, 0x75, 0x33,
	0x52, 0x50, 0x08, 0x8d, 0x37, 0x07, 0x83, 0xfd, 0xa3, 0xee, 0x35, 0xd4, 0x86, 0xfa, 0x11, 0x7e,
	0xb3, 0xdf, 0x0d, 0x8c, 0xf2, 0xc5, 0xee, 0xab, 0xc1, 0x7e, 0x77, 0x61, 0xaf, 0xfb, 0xdb, 0xfb,
	0xf5, 0xe0, 0xf7, 0xf7, 0xeb, 0xc1, 0x9f, 0xef, 0xd7, 0x83, 0x5f, 0xfe, 0x5a, 0xbf, 0x76, 0xdc,
	0xb4, 0x71, 0xdc, 0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x49, 0x03, 0x5c, 0x65, 0x0b, 0x00,
	0x00,
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsZero {
		i--
		if m.IsZero {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UnixNano != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.UnixNano))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastIncludedIndex != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.LastIncludedIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LastProcessed != nil {
		{
			size, err := m.LastProcessed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Svsholds) > 0 {
		for k := range m.Svsholds {
			v := m.Svsholds[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshot(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshot(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshot(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Channels) > 0 {
		for iNdEx := len(m.Channels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Channels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_IRCPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_IRCPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_IRCPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RemoteAddr) > 0 {
		i -= len(m.RemoteAddr)
		copy(dAtA[i:], m.RemoteAddr)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.RemoteAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Created != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.LoggedIn != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.LoggedIn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.LastSolvedCaptcha != nil {
		{
			size, err := m.LastSolvedCaptcha.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.LastNonPing != nil {
		{
			size, err := m.LastNonPing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.IrcPrefix != nil {
		{
			size, err := m.IrcPrefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.LastClientMessageId != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.LastClientMessageId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Server {
		i--
		if m.Server {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Pass) > 0 {
		i -= len(m.Pass)
		copy(dAtA[i:], m.Pass)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Pass)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Svid) > 0 {
		i -= len(m.Svid)
		copy(dAtA[i:], m.Svid)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Svid)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Modes) > 0 {
		for iNdEx := len(m.Modes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Modes[iNdEx])
			copy(dAtA[i:], m.Modes[iNdEx])
			i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Modes[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.InvitedTo) > 0 {
		for iNdEx := len(m.InvitedTo) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InvitedTo[iNdEx])
			copy(dAtA[i:], m.InvitedTo[iNdEx])
			i = encodeVarintSnapshot(dAtA, i, uint64(len(m.InvitedTo[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ThrottlingExponent != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.ThrottlingExponent))
		i--
		dAtA[i] = 0x50
	}
	if len(m.AwayMsg) > 0 {
		i -= len(m.AwayMsg)
		copy(dAtA[i:], m.AwayMsg)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.AwayMsg)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Operator {
		i--
		if m.Operator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.LastActivity != nil {
		{
			size, err := m.LastActivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Channels) > 0 {
		for iNdEx := len(m.Channels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Channels[iNdEx])
			copy(dAtA[i:], m.Channels[iNdEx])
			i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Channels[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Realname) > 0 {
		i -= len(m.Realname)
		copy(dAtA[i:], m.Realname)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Realname)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nick) > 0 {
		i -= len(m.Nick)
		copy(dAtA[i:], m.Nick)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Nick)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Auth) > 0 {
		i -= len(m.Auth)
		copy(dAtA[i:], m.Auth)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Auth)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Channel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Channel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Channel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Bans) > 0 {
		for iNdEx := len(m.Bans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Modes) > 0 {
		for iNdEx := len(m.Modes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Modes[iNdEx])
			copy(dAtA[i:], m.Modes[iNdEx])
			i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Modes[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Nicks) > 0 {
		for k := range m.Nicks {
			v := m.Nicks[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSnapshot(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshot(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshot(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0x22
	}
	if m.TopicTime != nil {
		{
			size, err := m.TopicTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TopicNick) > 0 {
		i -= len(m.TopicNick)
		copy(dAtA[i:], m.TopicNick)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.TopicNick)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Channel_Modes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Channel_Modes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Channel_Modes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mode) > 0 {
		for iNdEx := len(m.Mode) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Mode[iNdEx])
			copy(dAtA[i:], m.Mode[iNdEx])
			i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Mode[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Channel_BanPattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Channel_BanPattern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Channel_BanPattern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Regexp) > 0 {
		i -= len(m.Regexp)
		copy(dAtA[i:], m.Regexp)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Regexp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pattern) > 0 {
		i -= len(m.Pattern)
		copy(dAtA[i:], m.Pattern)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Pattern)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_SVSHold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_SVSHold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_SVSHold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x12
	}
	if m.Added != nil {
		{
			size, err := m.Added.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Banned) > 0 {
		for k := range m.Banned {
			v := m.Banned[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSnapshot(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshot(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshot(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.MaxChannels != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.MaxChannels))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxSessions != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.MaxSessions))
		i--
		dAtA[i] = 0x48
	}
	if m.CaptchaRequiredForLogin {
		i--
		if m.CaptchaRequiredForLogin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.CaptchaHmacSecret) > 0 {
		i -= len(m.CaptchaHmacSecret)
		copy(dAtA[i:], m.CaptchaHmacSecret)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.CaptchaHmacSecret)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CaptchaUrl) > 0 {
		i -= len(m.CaptchaUrl)
		copy(dAtA[i:], m.CaptchaUrl)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.CaptchaUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TrustedBridges) > 0 {
		for k := range m.TrustedBridges {
			v := m.TrustedBridges[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSnapshot(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSnapshot(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSnapshot(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PostMessageCooloff) > 0 {
		i -= len(m.PostMessageCooloff)
		copy(dAtA[i:], m.PostMessageCooloff)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.PostMessageCooloff)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SessionExpiration) > 0 {
		i -= len(m.SessionExpiration)
		copy(dAtA[i:], m.SessionExpiration)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.SessionExpiration)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Irc != nil {
		{
			size, err := m.Irc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnapshot(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Revision != 0 {
		i = encodeVarintSnapshot(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Config_IRC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Config_IRC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Config_IRC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Operators) > 0 {
		for iNdEx := len(m.Operators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Operators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnapshot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Config_IRC_Operator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Config_IRC_Operator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Config_IRC_Operator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot_Config_IRC_Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot_Config_IRC_Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot_Config_IRC_Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintSnapshot(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSnapshot(dAtA []byte, offset int, v uint64) int {
	offset -= sovSnapshot(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnixNano != 0 {
		n += 1 + sovSnapshot(uint64(m.UnixNano))
	}
	if m.IsZero {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Svsholds) > 0 {
		for k, v := range m.Svsholds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshot(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	if m.LastProcessed != nil {
		l = m.LastProcessed.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.LastIncludedIndex != 0 {
		n += 1 + sovSnapshot(uint64(m.LastIncludedIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_IRCPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Nick)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Realname)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if len(m.Channels) > 0 {
		for _, s := range m.Channels {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if m.LastActivity != nil {
		l = m.LastActivity.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.Operator {
		n += 2
	}
	l = len(m.AwayMsg)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.ThrottlingExponent != 0 {
		n += 1 + sovSnapshot(uint64(m.ThrottlingExponent))
	}
	if len(m.InvitedTo) > 0 {
		for _, s := range m.InvitedTo {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	l = len(m.Svid)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Pass)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.Server {
		n += 2
	}
	if m.LastClientMessageId != 0 {
		n += 2 + sovSnapshot(uint64(m.LastClientMessageId))
	}
	if m.IrcPrefix != nil {
		l = m.IrcPrefix.Size()
		n += 2 + l + sovSnapshot(uint64(l))
	}
	if m.LastNonPing != nil {
		l = m.LastNonPing.Size()
		n += 2 + l + sovSnapshot(uint64(l))
	}
	if m.LastSolvedCaptcha != nil {
		l = m.LastSolvedCaptcha.Size()
		n += 2 + l + sovSnapshot(uint64(l))
	}
	if m.LoggedIn != 0 {
		n += 2 + sovSnapshot(uint64(m.LoggedIn))
	}
	if m.Created != 0 {
		n += 2 + sovSnapshot(uint64(m.Created))
	}
	l = len(m.RemoteAddr)
	if l > 0 {
		n += 2 + l + sovSnapshot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Channel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.TopicNick)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.TopicTime != nil {
		l = m.TopicTime.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if len(m.Nicks) > 0 {
		for k, v := range m.Nicks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSnapshot(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Bans) > 0 {
		for _, e := range m.Bans {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Channel_Modes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mode) > 0 {
		for _, s := range m.Mode {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Channel_BanPattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Regexp)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_SVSHold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Added != nil {
		l = m.Added.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovSnapshot(uint64(m.Revision))
	}
	if m.Irc != nil {
		l = m.Irc.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.SessionExpiration)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.PostMessageCooloff)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if len(m.TrustedBridges) > 0 {
		for k, v := range m.TrustedBridges {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + len(v) + sovSnapshot(uint64(len(v)))
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	l = len(m.CaptchaUrl)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.CaptchaHmacSecret)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.CaptchaRequiredForLogin {
		n += 2
	}
	if m.MaxSessions != 0 {
		n += 1 + sovSnapshot(uint64(m.MaxSessions))
	}
	if m.MaxChannels != 0 {
		n += 1 + sovSnapshot(uint64(m.MaxChannels))
	}
	if len(m.Banned) > 0 {
		for k, v := range m.Banned {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + len(v) + sovSnapshot(uint64(len(v)))
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Config_IRC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Operators) > 0 {
		for _, e := range m.Operators {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Config_IRC_Operator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot_Config_IRC_Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSnapshot(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSnapshot(x uint64) (n int) {
	return sovSnapshot(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixNano", wireType)
			}
			m.UnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixNano |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsZero", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsZero = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &Snapshot_Session{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, &Snapshot_Channel{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svsholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Svsholds == nil {
				m.Svsholds = make(map[string]*Snapshot_SVSHold)
			}
			var mapkey string
			var mapvalue *Snapshot_SVSHold
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshot
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshot
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Snapshot_SVSHold{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshot(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshot
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Svsholds[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProcessed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastProcessed == nil {
				m.LastProcessed = &RobustId{}
			}
			if err := m.LastProcessed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Snapshot_Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIncludedIndex", wireType)
			}
			m.LastIncludedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastIncludedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_IRCPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IRCPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IRCPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &RobustId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastActivity == nil {
				m.LastActivity = &Timestamp{}
			}
			if err := m.LastActivity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operator = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwayMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwayMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottlingExponent", wireType)
			}
			m.ThrottlingExponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThrottlingExponent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitedTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvitedTo = append(m.InvitedTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modes = append(m.Modes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Server = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastClientMessageId", wireType)
			}
			m.LastClientMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastClientMessageId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IrcPrefix == nil {
				m.IrcPrefix = &Snapshot_IRCPrefix{}
			}
			if err := m.IrcPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastNonPing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastNonPing == nil {
				m.LastNonPing = &Timestamp{}
			}
			if err := m.LastNonPing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSolvedCaptcha", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSolvedCaptcha == nil {
				m.LastSolvedCaptcha = &Timestamp{}
			}
			if err := m.LastSolvedCaptcha.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedIn", wireType)
			}
			m.LoggedIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoggedIn |= Bool(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Channel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Channel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Channel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicNick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicNick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicTime == nil {
				m.TopicTime = &Timestamp{}
			}
			if err := m.TopicTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nicks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nicks == nil {
				m.Nicks = make(map[string]*Snapshot_Channel_Modes)
			}
			var mapkey string
			var mapvalue *Snapshot_Channel_Modes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshot
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSnapshot
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Snapshot_Channel_Modes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshot(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshot
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nicks[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modes = append(m.Modes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bans = append(m.Bans, &Snapshot_Channel_BanPattern{})
			if err := m.Bans[len(m.Bans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Channel_Modes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Modes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Modes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = append(m.Mode, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Channel_BanPattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BanPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BanPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regexp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_SVSHold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SVSHold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SVSHold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Added", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Added == nil {
				m.Added = &Timestamp{}
			}
			if err := m.Added.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Irc == nil {
				m.Irc = &Snapshot_Config_IRC{}
			}
			if err := m.Irc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionExpiration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostMessageCooloff", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostMessageCooloff = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedBridges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrustedBridges == nil {
				m.TrustedBridges = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshot
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSnapshot
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshot(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshot
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TrustedBridges[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptchaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaHmacSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptchaHmacSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaRequiredForLogin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CaptchaRequiredForLogin = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessions", wireType)
			}
			m.MaxSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChannels", wireType)
			}
			m.MaxChannels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxChannels |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Banned == nil {
				m.Banned = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSnapshot
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSnapshot
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSnapshot
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSnapshot
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSnapshot(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSnapshot
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Banned[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config_IRC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IRC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IRC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operators = append(m.Operators, &Snapshot_Config_IRC_Operator{})
			if err := m.Operators[len(m.Operators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &Snapshot_Config_IRC_Service{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config_IRC_Operator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config_IRC_Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSnapshot(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSnapshot
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSnapshot
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSnapshot
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSnapshot        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSnapshot          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSnapshot = fmt.Errorf("proto: unexpected end of group")
)
